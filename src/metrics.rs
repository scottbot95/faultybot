use std::env;
use std::net::{IpAddr, Ipv4Addr, SocketAddr, SocketAddrV4};
use std::time::Duration;
use lazy_static::lazy_static;
use metrics::{describe_counter, describe_histogram};
use metrics_exporter_prometheus::PrometheusBuilder;
use metrics_util::MetricKindMask;
use serenity::futures::TryFutureExt;
use tracing::error;

lazy_static! {
    static ref DEFAULT_SOCKET_ADDR: SocketAddr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::new(0,0,0,0)),
        9000
    );
}

pub(crate) fn init_metrics() {
    let address = env::var("METRICS_LISTEN_ADDRESS")
        .map(|addr| addr.parse().unwrap_or_else(|e| {
            error!(
                "Unable to parse provided listen socket `{}`. Using default instead: {}",
                e,
                *DEFAULT_SOCKET_ADDR
            );
            *DEFAULT_SOCKET_ADDR
        }));

    if let Ok(address) = address {
        PrometheusBuilder::new()
            .idle_timeout(
                MetricKindMask::COUNTER | MetricKindMask::HISTOGRAM,
                Some(Duration::from_secs(10))
            )
            .with_http_listener(address)
            .install()
            .expect("failed to install Prometheus recorder");
    }


    // We register these metrics, which gives us a chance to specify a description for them.  The
    // Prometheus exporter records this description and adds it as HELP text when the endpoint is
    // scraped.
    //
    // Registering metrics ahead of using them is not required, but is the only way to specify the
    // description of a metric.
    describe_counter!("faultybot_errors_total", "The total number of errors");
    describe_counter!("faultybot_gpt_requests_total", "The total number of response requests to FaultyGPT");
    describe_counter!("faultybot_gpt_responses_total", "The total number of responses provided by FaultyGPT");
    describe_histogram!(
        "faultybot_gpt_response_seconds",
        "The time take for a GPT a response to be generated by FaultyGPT"
    );
}