use std::env;
use std::error::Error;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use metrics::{describe_counter, describe_gauge, describe_histogram, NoopRecorder, register_gauge};
use metrics_exporter_prometheus::PrometheusBuilder;
use metrics_exporter_statsd::StatsdBuilder;
use metrics_util::MetricKindMask;
use serenity::CacheAndHttp;
use tokio::time;
use tracing::{info, warn};

pub(crate) fn init_metrics() {
    if install_prometheus_recorder().expect("Failed to install Prometheus recorder") {
        info!("Installed Prometheus metrics recorder");
        describe_metrics();
    } else if install_statsd_recorder().expect("Failed to install StatsD recorder") {
        info!("Installed Statsd metrics recorder");
        // Nothing (yet?)
    } else {
        warn!("No metrics recorder specified, defaulting to NoopRecorder");
        metrics::set_recorder(&NoopRecorder).expect("Failed to install NoopRecorder");
    }

}

/// Periodically emit metrics about bot state
pub(crate) fn periodic_metrics(cache_and_http: Arc<CacheAndHttp>, period: Duration) {
    tokio::spawn(async move {
        let mut interval = time::interval(period);
        let guild_count_gauge = register_gauge!("faultybot_guilds_in_cache");

        loop {
            interval.tick().await;

            let guild_count = cache_and_http.cache.guild_count();
            guild_count_gauge.set(guild_count as f64);
        }
    });
}

/// We register these metrics, which gives us a chance to specify a description for them.  The
/// Prometheus exporter records this description and adds it as HELP text when the endpoint is
/// scraped.
///
/// Registering metrics ahead of using them is not required, but is the only way to specify the
/// description of a metric.
fn describe_metrics() {
    describe_counter!("faultybot_errors_total", "The total number of errors");
    describe_counter!("faultybot_gpt_requests_total", "The total number of response requests to FaultyGPT");
    describe_counter!("faultybot_gpt_responses_total", "The total number of responses provided by FaultyGPT");
    describe_histogram!(
        "faultybot_gpt_response_seconds",
        "The time take for a GPT a response to be generated by FaultyGPT"
    );
    describe_gauge!(
        "faultybot_guilds_in_cache",
        "The number of guilds currently in the serenity cache. This value is shared across shards."
    );
}

fn install_prometheus_recorder() -> Result<bool, Box<dyn Error>> {
    let address = match env::var("METRICS_LISTEN_ADDRESS") {
        Ok(addr) => addr.parse::<SocketAddr>()?,
        Err(_) => return Ok(false),
    };

    PrometheusBuilder::new()
        .idle_timeout(
            MetricKindMask::COUNTER | MetricKindMask::HISTOGRAM,
            Some(Duration::from_secs(10)),
        )
        .with_http_listener(address)
        .install()?;

    Ok(true)
}

fn install_statsd_recorder() -> Result<bool, Box<dyn Error>> {
    let host = match env::var("STATSD_HOST") {
        Ok(host) => host,
        Err(_) => return Ok(false),
    };
    let port = match env::var("STATSD_PORT") {
        Ok(port) => port.parse()?,
        Err(_) => return Ok(false),
    };

    let recorder = StatsdBuilder::from(host, port)
        .histogram_is_timer()
        .build(Some("faultybot"))?;

    metrics::set_boxed_recorder(Box::new(recorder))?;

    Ok(true)
}
